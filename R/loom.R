#
# loom.R
#
library(hdf5r)

##############################
# Global Meta data functions #
##############################

#'
#'@description  Add the embedding with the given name to the global MetaData attribute.
#'@param loom   The loom file handler.
#'@param name   The name of the annotation.
#'@param values The values of the annotation to be added.
#'
add_global_md_annotation<-function(loom
                                 , name
                                 , values) {
  gmd<-get_global_meta_data(loom = loom)
  a<-gmd[["annotations"]]
  a[[length(a)+1]]<-list(name = name, values = as.character(unique(values)))
  gmd[["annotations"]]<-NULL
  gmd[["annotations"]]<-a
  update_global_meta_data(loom = loom, meta.data.json = rjson::toJSON(x = gmd))
}

#'
#'@description  Add the embedding with the given name to the global MetaData attribute.
#'@param loom       The loom file handler.
#'@param name       The name of the embedding to add.
#'@param is.default Is the given embedding the default embedding to use in the .loom file.
#'
add_global_md_embedding<-function(loom
                                , name
                                , is.default = F) {
  gmd<-get_global_meta_data(loom = loom)
  e<-gmd[["embeddings"]]
  if(is.default) {
    id<-(-1)
  } else {
    id<-length(e)-1
  }
  e[[length(e)+1]]<-list(id = id, name = name)
  gmd[["embeddings"]]<-NULL
  gmd[["embeddings"]]<-e
  update_global_meta_data(loom = loom, meta.data.json = rjson::toJSON(x = gmd))
}

#'
#'@description  Add the clustering annotation to the global MetaData attribute.
#'@param loom                               The loom file handler.
#'@param group                              The name of the group of clusterings
#'@param name                               The name given to the given clustering.
#'@param clusters                           A list of the the cluster id for each cell present in the same order as in the columns of gene expression matrix
#'@param annotation.cluster.id.cl           The column name to use for the IDs of the clusters found by the given clustering group.
#'@param annotation.cluster.description.cl  The column name to use for the description of the clusters found by the given clustering group.
#'
add_global_md_clustering<-function(loom
                                 , group
                                 , name
                                 , clusters
                                 , annotation = NULL
                                 , annotation.cluster.id.cl = NULL
                                 , annotation.cluster.description.cl = NULL) {
  gmd<-get_global_meta_data(loom = loom)
  c<-gmd[["clusterings"]]
  unique.clusters<-sort(as.numeric(unique(seurat@ident))-1, decreasing = F)
  clusters<-lapply(X = unique.clusters, FUN = function(cluster.id) {
    description<-paste("NDA - Cluster", cluster.id)
    if(!is.null(annotation)) {
      # If annotation for the current cluster not empty then add
      d<-annotation[annotation[[annotation.cluster.id.cl]] == cluster.id, annotation.cluster.description.cl]
      if(nchar(d)>0) {
        description<-paste0(d, " (",cluster.id,")")
      }
    }
    return (list(id = cluster.id
                 , description = description))
  })
  ca<-loom[["col_attrs"]]
  clusterings<-ca[["Clusterings"]][]
  clustering<-list(id = ncol(clusterings)+1, # n clusterings
                   group = group,
                   name = name,
                   clusters = clusters)
  c[[length(c)+1]]<-clustering
  gmd[["clusterings"]]<-NULL
  gmd[["clusterings"]]<-c
  update_global_meta_data(loom = loom, meta.data.json = rjson::toJSON(x = gmd))
  loom$flush
}

#'
#'@description  Add the regulon thresholds annotation to the global MetaData attribute.
#'@param loom                           The loom file handler.
#'@param regulon.threshold.assignments  The automated regulon cell assignments object generated by SCENIC.
#'
add_global_md_regulon_thresholds<-function(loom
                                         , regulon.threshold.assignments) {
  gmd<-get_global_meta_data(loom = loom)
  rT<-gmd[["regulonThresholds"]]
  for(regulon in names(regulon.threshold.assignments)) {
    rta<-regulon.threshold.assignments[[regulon]]
    AUC.thresholds<-rta$aucThr$thresholds
    allThresholds<-do.call(what = "c", args = lapply(X = row.names(AUC.thresholds), FUN = function(threshold.name) {
      l<-list()
      l[[threshold.name]]<-AUC.thresholds[threshold.name,"threshold"]
      return (l)
    }))
    AUC.selected.threshold<-rta$aucThr$selected
    regulon.tresholds<-list(regulon = regulon, # n clusterings
                            defaultThresholdValue = AUC.selected.threshold[names(AUC.selected.threshold)],
                            defaultThresholdName = names(AUC.selected.threshold),
                            allThresholds = allThresholds)
    rT[[length(rT)+1]]<-regulon.tresholds
  }
  gmd[["regulonThresholds"]]<-NULL
  gmd[["regulonThresholds"]]<-rT
  loom$flush
  update_global_meta_data(loom = loom, meta.data.json = rjson::toJSON(x = gmd))
  loom$flush
}

#'
#'@description Get the global MetaData attribute as a R object.
#'@param loom The loom file handler.
#'
get_global_meta_data<-function(loom) {
  return (rjson::fromJSON(json_str = h5attr(x = loom, which = "MetaData")))
}

update_global_meta_data<-function(loom
                                  , meta.data.json) {
  h5attr(x = loom, which = "MetaData")<-as.character(meta.data.json)
}

init_global_meta_data<-function(loom) {
  meta.data<-list(annotations = list()
                , embeddings = list()
                , clusterings = list()
                , regulonThresholds = list())
  meta.data.json<-rjson::toJSON(meta.data)
  if(!("MetaData"%in%list.attributes(object = loom))) {
    loom$create_attr(attr_name = "MetaData", robj = as.character(meta.data.json), dtype = H5T_STRING$new(size=Inf))
  } else {
    update_global_meta_data(loom = loom, meta.data.json = as.character(meta.data.json))
  }
}

#######################
# Embedding functions #
#######################

#'
#'@description Add the given embedding as a row attribute and meta data related to the given embeddding to the given .loom file handler.
#'@param loom       The loom file handler.
#'@param embedding  A M-by-2 data.frame of the embeddings with M cells.
#'@param name       The name of the given embedding.
#'@param is.default Is the given embedding the default embedding to use in the .loom file.
#'
add_embedding<-function(loom
                        , embedding
                        , name
                        , is.default = F) {
  coord.labels<-c("Embeddings_X", "Embeddings_Y")
  if(is.default) {
    embedding<-as.data.frame(embedding)
    colnames(embedding)<-c("_X","_Y")
    add_col_attr(loom = loom, key = "Embedding", value = embedding)
  } else {
    ca<-loom[["col_attrs"]]
    if(sum(c("Embeddings_X","Embeddings_Y")%in%names(ca)) != 2) {
      for(i in seq_along(coord.labels)) {
        e<-as.data.frame(embedding[,i])
        colnames(e)<-"_0"
        add_col_attr(loom = loom, key = coord.labels[i], value = e)
      }
    } else {
      for(i in seq_along(coord.labels)) {
        ca.embeddings<-get_col_attr_by_key(loom = loom, key = coord.labels[i])
        e<-as.data.frame(embedding[,i])
        colnames(e)<-paste0("_",ncol(ca.embeddings))
        ca.embeddings<-cbind(ca.embeddings, e)
        # Update the current coordinates Embeddings
        update_col_attr(loom = loom, key = coord.labels[i], value = as.data.frame(ca.embeddings))
      }
    }
  }
  loom$flush()
  # Add the given embedding to the global attribute MetaData
  add_global_md_embedding(loom = loom, name = name, is.default = is.default)
  loom$flush()
}

#########################
# Clusterings functions #
#########################

#'
#'@description Add all the Seurat clusterings in the given seurat object to the given .loom file handler.
#'@param loom                               The loom file handler.
#'@param seurat                             The Seurat object
#'@param default.clustering.resolution      The clustering resolution (i.e.: res.2, ...) of the clustering that should be set as the default.
#'@param seurat.markers.file.path.list      The named list of file paths to the markers saved in RDS format. The names should be the resolution id of the corresponding clustering (e.g.: res2.0).
#'@param annotation                         A data.frame with annotation for the clusters
#'@param annotation.cluster.id.cl           The column name to use for the IDs of the clusters found by the given clustering group.
#'@param annotation.cluster.description.cl  The column name to use for the description of the clusters found by the given clustering group.
#'
add_seurat_clustering<-function(loom
                                , seurat
                                , default.clustering.resolution
                                , seurat.markers.file.path.list
                                , annotation
                                , annotation.cluster.id.cl
                                , annotation.cluster.description.cl) {
  clustering.resolutions<-as.numeric(stringr::str_split_fixed(string = names(seurat@calc.params)[grep(pattern = "FindClusters", x = names(seurat@calc.params))], pattern = "FindClusters.res.", n = 2)[,2])
  for(res in clustering.resolutions) {
    seurat<-SetAllIdent(object = seurat, id = paste0("res.",res))
    cluster.ids<-seurat@ident
    is.default.clustering<-F
    # Add the Seurat clusters
    print("Adding Seurat clusters...")
    a<-NULL
    ac.id.cl<-NULL
    ac.description.cl<-NULL
    if(res == default.clustering.resolution) {
      print("Adding default Seurat clusters...")
      a<-annotation
      ac.id.cl<-annotation.cluster.id.cl
      ac.description.cl<-annotation.cluster.description.cl
      is.default.clustering<-T
    }
    loom$flush()
    add_clustering(loom = loom
                   , group = "Seurat"
                   , name = paste("Seurat, resolution",res)
                   , clusters = cluster.ids
                   , is.default = is.default.clustering
                   , annotation = a
                   , annotation.cluster.id.cl = ac.id.cl
                   , annotation.cluster.description.cl = ac.description.cl)
    loom$flush()
    # Add the Seurat markers
    print("Adding Seurat markers...")
    seurat.markers<-readRDS(file = seurat.markers.file.path.list[[paste0("res.", res)]])
    seurat.m.list<-split(x = seurat.markers, f = seurat.markers$cluster)
    seurat.m.list<-lapply(X = seurat.m.list, function(cluster) {
      return (cluster$gene)
    })
    add_clustering_markers(loom = loom, clustering.id = res, clustering.markers = seurat.m.list)
    loom$flush()
  }
}

#'
#'@description Add the given clusters in the given group column attribute and meta data related to the given clustering to the given .loom file handler.
#'@param loom                               The loom file handler.
#'@param group                              The for the given clustering group to which the given clusters have to be added
#'@param clusters                           A list of the the cluster id for each cell present in the matrix
#'@param annotation                         A data.frame with annotation for the clusters
#'@param annotation.cluster.id.cl           The column name to use for the IDs of the clusters found by the given clustering group.
#'@param annotation.cluster.description.cl  The column name to use for the description of the clusters found by the given clustering group.
#'
add_clustering<-function(loom
                         , group
                         , name
                         , clusters
                         , is.default = F
                         , annotation = NULL
                         , annotation.cluster.id.cl =  NULL
                         , annotation.cluster.description.cl = NULL) {
  # If the clustering is the default one
  # Add it as the generic column attributes ClusterID and ClusterName
  if(is.default) {
    add_col_attr(loom = loom, key = "ClusterID", value = clusters)
    unique.clusters<-sort(as.numeric(unique(clusters))-1, decreasing = F)
    for(cluster in unique.clusters) {
      description<-paste0("NDA - Cluster ", cluster)
      names(clusters)<-description
      if(!is.null(annotation)) {
        description<-annotation[annotation[[annotation.cluster.id.cl]] == cluster, annotation.cluster.description.cl]
      }
      names(clusters)[clusters == cluster]<-description
    }
    add_col_attr(loom = loom, key = "ClusterName", value = names(clusters))
  }
  # Adding the clustering data
  k<-"Clusterings"
  if(col_attrs_exists_by_key(loom = loom, key = k)) {
    print("Clusterings already exists...")
    ca.clusterings<-get_col_attr_by_key(loom = loom, key = k)
    clustering<-data.frame(x = clusters)
    colnames(clustering)<-as.character(ncol(ca.clusterings)+1)
    ca.clusterings<-cbind(ca.clusterings, clustering)
    update_col_attr(loom = loom, key = k, value = as.data.frame(x = ca.clusterings))
  } else {
    print("Clusterings created...")
    clustering<-data.frame("0" = clusters)
    add_col_attr(loom = loom, key = k, value = as.data.frame(x = clustering))
  }
  loom$flush()
  # Adding the clustering meta data
  add_global_md_clustering(loom = loom
                           , group = group
                           , name = name
                           , annotation = annotation
                           , annotation.cluster.id.cl = annotation.cluster.id.cl
                           , annotation.cluster.description.cl = annotation.cluster.description.cl)
  loom$flush()
}

add_cluster_markers<-function(loom
                              , clustering.id
                              , cluster.id
                              , markers) {
  genes<-get_genes(loom = loom, is.flybase.gn = F)
  # Adding the cluster markers data
  k<-paste0("ClusteringMarkers","_",clustering.id)
  if(col_attrs_exists_by_key(loom = loom, key = k)) {
    ca.clustering.markers.df<-get_col_attr_by_key(loom = loom, key = k)
    cluster.markers.df<-data.frame(x = genes %in% markers)
    colnames(clusters.df)<-as.character(ncol(ca.clustering.markers.df)+1)
    ca.clustering.markers.df<-cbind(ca.clustering.markers.df, cluster.markers.df)
    add_col_attr(loom = loom, key = k, value = as.data.frame(x = ca.clustering.markers.df))
  } else {
    clustering<-data.frame("0" = genes %in% markers)
    add_col_attr(loom = loom, key = k, value = as.data.frame(x = clustering))
  }
  loom$flush()
}

####################
# SCENIC functions #
####################

#'
#'@description Add the regulons with their target genes generated by SCENIC as a row attribute to the given .loom file handler.
#'@param loom     The loom file handler.
#'@param dgem     A matrix of the gene expression with M genes as rows and N cells as columns.
#'@param regulons A list of list of the regulons and their target genes generated by SCENIC.
#'
add_scenic_regulons<-function(loom
                              , dgem
                              , regulons) {
  regulons.mask<-do.call(what = "cbind", args = lapply(seq_along(regulons), function(regulon.idx) {
    reg.name<-names(regulons)[regulon.idx]
    reg.genes<-regulons[regulon.idx]
    reg.mask<-data.frame("x"=row.names(dgem)%in%reg.genes, stringsAsFactors = F)
    colnames(reg.mask)<-reg.name
    return (reg.mask)
  }))
  row.names(regulons.mask)<-row.names(dgem)
  colnames(regulons.mask)<-gsub(pattern = " ", replacement = "_", x = colnames(regulons.mask))
  add_row_attr(loom = loom, key = "Regulons", value = as.data.frame(x = regulons.mask))
  loom$flush()
}

#'
#'@description Add the regulons AUC matrix generated by SCENIC as a column attribute to the given .loom file handler.
#'@param loom         The loom file handler.
#'@param regulons.AUC A matrix of the regulons AUC values with M regulons as rows and N cells as columns.
#'
add_scenic_regulons_auc_matrix<-function(loom
                                         , regulons.AUC) {
  add_col_attr(loom = loom, key = "RegulonsAUC", value = as.data.frame(x = t(regulons.AUC)))
  loom$flush()
}

###########################
# Row Meta data functions #
###########################

#'
#'@description Add the clustering markers as a row attribute to the given .loom file handler.
#'@param loom           The loom file handler.
#'@param dgem           A matrix of the gene expression with M genes as rows and N cells as columns.
#'@param clustering.id  The clustering id that the given clustering.markers are specific for.
#'@param regulons       A list of list of the clustering markers.
#'
add_clustering_markers<-function(loom
                               , clustering.id
                               , clustering.markers) {
  genes<-get_genes(loom = loom, is.flybase.gn = F)
  clustering.markers.mask<-do.call(what = "cbind", args = lapply(seq_along(clustering.markers), function(cluster.idx) {
    cluster.name<-names(clustering.markers)[cluster.idx]
    cluster.markers<-clustering.markers[cluster.idx]
    cm.mask<-data.frame("x" = genes %in% cluster.markers, stringsAsFactors = F)
    colnames(cm.mask)<-cluster.name
    return (cm.mask)
  }))
  row.names(clustering.markers.mask)<-genes
  clustering.id<-ncol(loom[["col_attrs"]][["Clusterings"]][])-1
  print(paste0("Adding markers for clustering ID ", clustering.id))
  add_row_attr(loom = loom, key = paste0("ClusteringMarkers_",clustering.id), value = as.data.frame(x = clustering.markers.mask))
  loom$flush()
}

#'
#'@description Get the gene names either symbols or Flybase gene identifiers.
#'@param loom           The loom file handler.
#'@param is.flybase.gn  Whether to retrieve the Flybase gene identifiers or not.
#'
get_genes<-function(loom
                    , is.flybase.gn = F) {
  ra<-loom[["row_attrs"]]
  if(is.flybase.gn) {
    return (ra[["FBgn"]])
  }
  return (ra[["Gene"]][])
}

#'
#'@description Add the Flybase gene as a row attribute to the given .loom file handler.
#'@param loom                       The loom file handler.
#'@param dgem                       A matrix of the gene expression with M genes as rows and N cells as columns.
#'@param fbgn.gn.mapping.file.path  A N-by-2 data.frame containing the mapping between the Flybase gene and the gene symbol.
#'
add_fbgn<-function(loom
                   , dgem
                   , fbgn.gn.mapping.file.path) {
  fbgn.gn.mapping<-read.table(file = fbgn.gn.mapping.file.path, header = F, sep = "\t", quote = '', stringsAsFactors = F)
  colnames(fbgn.gn.mapping)<-c("FBgn","Gene")
  genes<-merge(x = data.frame("Gene"=row.names(dgem)), y = fbgn.gn.mapping, by = "Gene")
  add_row_attr(loom = loom, key = "FBgn", value = genes$FBgn)
}

#####################
# Generic functions #
#####################

lookup_all_global_attr<-function(loom) {
  list.attributes(object = loom)
}

remove_global_attr<-function(loom
                             , key) {
  loom$attr_delete(attr_name = key)
  loom$flush()
}

get_global_attr<-function(loom
                          , key) {
  h5attr(x = loom, which = key)
}

#'
#'@description Add a new global attribute to the given .loom object accessible by the given key and containing the given value.
#'@param loom   The loom file handler.
#'@param key    The name of the new added attribute.
#'@param value  The value of the new added attribute.
#'
add_global_attr<-function(loom
                          , key
                          , value) {
  loom$create_attr(attr_name = key, robj = value, dtype = getDtype(x = value))
  loom$flush()
}

remove_row_attr<-function(loom
                          , key) {
  loom$link_delete(name = paste0("row_attrs/", key))
  loom$flush()
}

update_row_attr<-function(loom
                          , key
                          , value) {
  loom$link_delete(name = paste0("row_attrs/",key))
  add_col_attr(loom = loom, key = key, value = value)
}

#'
#'@description Add a new row attribute to the given .loom object accessible by the given key and containing the given value.
#'@param loom   The loom file handler.
#'@param key    The name of the new added attribute.
#'@param value  The value of the new added attribute.
#'
add_row_attr<-function(loom
                       , key
                       , value) {
  ra<-loom[["row_attrs"]]
  ra[[key]]<-value
  loom$flush()
}

col_attrs_exists_by_key<-function(loom
                                , key) {
  ca<-loom[["col_attrs"]]
  return (key %in% names(ca))
}

get_col_attr_by_key<-function(loom
                            , key) {
  ca<-loom[["col_attrs"]]
  return (ca[[key]][])
}

remove_col_attr<-function(loom
                          , key) {
  loom$link_delete(name = paste0("col_attrs/", key))
  loom$flush()
}

update_col_attr<-function(loom
                          , key
                          , value) {
  loom$link_delete(name = paste0("col_attrs/",key))
  add_col_attr(loom = loom, key = key, value = value)
}

#'
#'@description Add a new column attribute to the given .loom object accessible by the given key and containing the given value.
#'@param loom   The loom file handler.
#'@param key    The name of the new added attribute.
#'@param value  The value of the new added attribute.
#'
add_col_attr<-function(loom
                       , key
                       , value
                       , as.md.annotation = F) {
  ca<-loom[["col_attrs"]]
  ca[[key]]<-value
  loom$flush()
  if(as.md.annotation) {
    add_global_md_annotation(loom = loom, name = key, values = value)
    loom$flush()
  }
}

#'
#'@description Add the given gene expression matrix dgem to the given .loom object.
#'@param loom The loom file handler.
#'@param dgem A matrix of the gene expression with M genes as rows and N cells as columns.
#'
add_matrix<-function(loom
                     , dgem
                     , chunk.size
                     , display.progress) {
  row.names(dgem)<-NULL
  colnames(dgem)<-NULL
  dtype<-getDtype(x = dgem[1, 1])
  loom$create_dataset(
    name = 'matrix',
    dtype = dtype,
    dims = rev(x = dim(x = dgem))
  )
  chunk.points<-chunkPoints(
    data.size = dim(x = dgem)[2],
    chunk.size = chunk.size
  )
  if (display.progress) {
    pb<-txtProgressBar(char = '=', style = 3)
  }

  for (col in 1:ncol(x = chunk.points)) {
    row.start <- chunk.points[1, col]
    row.end <- chunk.points[2, col]
    loom[['matrix']][row.start:row.end, ] <- t(x = as.matrix(x = dgem[, row.start:row.end]))
    if(display.progress) {
      setTxtProgressBar(pb = pb, value = col / ncol(x = chunk.points))
    }
  }
  loom$flush()
}

#'
#'@description
#'@loom The loom file handler.
#'
finalize<-function(loom) {
  loom$flush()
  loom$close_all()
}

#'
#'@param file.name                  A string naming the .loom file to be generated.
#'@param dgem                       A matrix of the gene expression with M genes as rows and N cells as columns.
#'@param default.embedding          A M-by-2 data.frame of the embedding (X and Y coordinates) of the cells.
#'@param fbgn.gn.mapping.file.path  A N-by-2 data.frame containing the mapping between the Flybase gene and the gene symbol.
#'
build_loom<-function(file.name
                     , title = NULL
                     , genome = NULL
                     , dgem
                     , default.embedding
                     , default.embedding.name
                     , fbgn.gn.mapping.file.path
                     , chunk.size = 1000
                     , display.progress = T) {
  loom<-H5File$new(filename = file.name, mode = "w")
  # title
  if(!is.null(title)) {
    add_global_attr(loom = loom, key = "title", value = as.character(title))
  }
  # Genome
  if(!is.null(genome)) {
    add_global_attr(loom = loom, key = "Genome", value = as.character(genome))
  }
  cn<-colnames(dgem)
  rn<-row.names(dgem)
  print("Adding global attributes...")
  # global MetaData attribute
  init_global_meta_data(loom = loom)
  # matrix
  # Check the type of the sparse matrix
  # convert to dgCMatrix if necessary to speedup populating the matrix slot
  if(class(dgem) == "dgTMatrix") {
    print("Converting to dgCMatrix...")
    dgem<-as(object = dgem, Class = "dgCMatrix")
  }
  print("Adding matrix...")
  add_matrix(loom = loom, dgem = dgem, chunk.size = chunk.size, display.progress = display.progress)
  # col_attrs
  print("Adding column attributes...")
  loom$create_group("col_attrs")
  add_col_attr(loom = loom, key = "CellID", value = as.character(cn))
  # Add the default embedding
  add_embedding(loom = loom, embedding = as.data.frame(default.embedding), name = default.embedding.name, is.default = T)
  # row_attrs
  print("Adding row attributes...")
  loom$create_group("row_attrs")
  add_row_attr(loom = loom, key = "Gene", value = as.character(rn))
  add_fbgn(loom = loom, dgem = dgem, fbgn.gn.mapping.file.path = fbgn.gn.mapping.file.path)
  # col_edges
  print("Adding columns edges...")
  col.edges<-loom$create_group("col_edges")
  # row_edges
  print("Adding row edges...")
  row.edges<-loom$create_group("row_edges")
  # layers
  print("Adding layers...")
  layers<-loom$create_group("layers")
  loom$flush()
}

lookup_loom<-function(loom) {
  loom$ls(recursive=TRUE)
}

open_loom<-function(file.path) {
  return (H5File$new(file.path, mode="r+"))
}

# Utils (loomR)

# Generate chunk points
#
# @param data.size How big is the data being chunked
# @param chunk.size How big should each chunk be
#
# @return A matrix where each column is a chunk, row 1 is start points, row 2 is end points
#
chunkPoints<-function(data.size, chunk.size) {
  return(vapply(
    X = 1L:ceiling(data.size / chunk.size),
    FUN = function(i) {
      return(c(
        start = (chunk.size * (i - 1L)) + 1L,
        end = min(chunk.size * i, data.size)
      ))
    },
    FUN.VALUE = numeric(length = 2L)
  ))
}

# Get HDF5 data types
#
# @param x An R object or string describing HDF5 datatype
#
# @return The corresponding HDF5 data type
#
# @ rdname getDtype
#
#' @import hdf5r
#
# @seealso \code\link{hdf5r::h5types}
#
getDtype<-function(x) {
  return(switch(
    EXPR = class(x = x),
    'numeric' = h5types$double,
    'integer' = h5types$int,
    'character' = H5T_STRING$new(size = Inf),
    'logical' = H5T_LOGICAL$new(),
    stop(paste("Unknown data type:", class(x = x)))
  ))
}
